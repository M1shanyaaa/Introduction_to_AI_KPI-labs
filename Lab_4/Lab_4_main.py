# Lab_4_main.py# Лабораторна робота 4 — система контролю швидкості на основі CNN (MNIST digits 2..9)import osimport randomimport networkx as nximport matplotlibmatplotlib.use("TkAgg")import matplotlib.pyplot as pltfrom collections import defaultdict# --- ML imports (TensorFlow) ---import numpy as npimport tensorflow as tffrom tensorflow.keras import layers, modelsfrom tensorflow.keras.utils import to_categorical# ------------------- Create_Graph (як у попередніх lab) -------------------class Create_Graph:    def __init__(self, n, remove_edges):        self.n = n        self.remove_edges = remove_edges        self.graph = None        self.edge_speed = {}  # map edge (u,v) -> digit 2..9 (speed limit = digit*10)        self.generate_graph()    def generate_graph(self):        self.graph = nx.grid_2d_graph(self.n, self.n)        edges = list(self.graph.edges())        random.shuffle(edges)        removed = 0        for u, v in edges:            if removed >= self.remove_edges:                break            self.graph.remove_edge(u, v)            if not nx.is_connected(self.graph):                self.graph.add_edge(u, v)            else:                removed += 1        return self.graph    def assign_random_speed_signs(self):        """Призначає випадкові знаки (цифра 2..9) кожному ребру графа.           Зберігає у self.edge_speed для обох напрямків (u,v) і (v,u)."""        for u, v in self.graph.edges():            digit = random.randint(2, 9)            self.edge_speed[(u, v)] = digit            self.edge_speed[(v, u)] = digit    def visualization_with_speeds(self):        pos = {node: (node[1], -node[0]) for node in self.graph.nodes()}        plt.figure(figsize=(6, 6))        nx.draw(self.graph, pos, node_color="white", edgecolors="black", node_size=200)        # draw edge labels (speed limits)        edge_labels = {}        drawn = set()        for (u, v), digit in self.edge_speed.items():            if (v, u) in drawn:                continue            edge_labels[(u, v)] = f"{digit*10}"            drawn.add((u, v))            drawn.add((v, u))        nx.draw_networkx_edge_labels(self.graph, pos, edge_labels=edge_labels, font_size=8)        plt.title("Graph with speed limits (km/h)")        plt.show()# ------------------- CNN (MNIST digits 2..9) -------------------def prepare_mnist_2_9():    """Завантажує MNIST та повертає (x_train, y_train), (x_test, y_test) для цифр 2..9."""    (x_train, y_train), (x_test, y_test) = tf.keras.datasets.mnist.load_data()    # Фільтруємо цифри 2..9    mask_train = np.isin(y_train, np.arange(2, 10))    mask_test = np.isin(y_test, np.arange(2, 10))    x_train, y_train = x_train[mask_train], y_train[mask_train]    x_test, y_test = x_test[mask_test], y_test[mask_test]    # нормалізація і reshape для CNN: (28,28,1)    x_train = x_train.astype("float32") / 255.0    x_test = x_test.astype("float32") / 255.0    x_train = np.expand_dims(x_train, -1)    x_test = np.expand_dims(x_test, -1)    # Перемаппінг міток: залишимо справжні цифри 2..9 (зручно для speed = label*10)    # але для Keras треба one-hot: зробимо to_categorical з num_classes=10 і використаємо offset при pred    y_train_cat = to_categorical(y_train, num_classes=10)    y_test_cat = to_categorical(y_test, num_classes=10)    return (x_train, y_train, y_train_cat), (x_test, y_test, y_test_cat)def build_cnn():    model = models.Sequential([        layers.Conv2D(32, (3,3), activation='relu', input_shape=(28,28,1)),        layers.MaxPooling2D((2,2)),        layers.Conv2D(64, (3,3), activation='relu'),        layers.MaxPooling2D((2,2)),        layers.Flatten(),        layers.Dense(64, activation='relu'),        layers.Dense(10, activation='softmax')  # logits for 0..9    ])    model.compile(optimizer='adam', loss='categorical_crossentropy', metrics=['accuracy'])    return model# ------------------- Agent with speed control -------------------class Agent:    def __init__(self, graph, edge_speed_map, mnist_images_by_label, model,                 start, goal):        self.graph = graph        self.edge_speed_map = edge_speed_map  # (u,v)->digit        self.mnist_images_by_label = mnist_images_by_label  # dict digit->list of imgs        self.model = model        self.start = start        self.goal = goal        self.position = start        self.path = [start]        self.visited_nodes = {start}        self.visited_edges = set()        self.traversed_speeds = []  # list of (u,v,speed_kmh)    def see_neighbors(self):        return list(self.graph.neighbors(self.position))    def perceive_speed_sign_on_edge(self, to_node):        """Імітація камери: повертаємо 28x28 зображення з MNIST для digit, де digit= edge_speed_map[(pos,to_node)]."""        digit = self.edge_speed_map.get((self.position, to_node), random.randint(2,9))        imgs = self.mnist_images_by_label.get(digit)        if imgs:            img = random.choice(imgs)  # already normalized and shaped (28,28,1)        else:            # fallback: create blank image with digit encoded (rare)            img = np.zeros((28,28,1), dtype=np.float32)        return img, digit    def recognize_speed(self, img):        """Використовує CNN model щоб передбачити цифру 0..9, повертає digit (int)."""        # model expects batch        pred = self.model.predict(np.expand_dims(img, axis=0), verbose=0)        label = int(np.argmax(pred[0]))        return label    def move_with_speed(self, next_node):        """Перед рухом розпізнаємо знак і встановлюємо швидкість."""        if next_node not in self.graph.neighbors(self.position):            raise ValueError("Неможливо рухатись: ребро відсутнє.")        img, true_digit = self.perceive_speed_sign_on_edge(next_node)        pred_digit = self.recognize_speed(img)        speed_kmh = pred_digit * 10        # збережемо результати        self.traversed_speeds.append(((self.position, next_node), speed_kmh, true_digit, pred_digit))        # звична логіка переміщення        self.visited_edges.add((self.position, next_node))        self.visited_edges.add((next_node, self.position))        self.visited_nodes.add(next_node)        self.position = next_node        self.path.append(next_node)    def heuristic(self, node):        return abs(node[0] - self.goal[0]) + abs(node[1] - self.goal[1])    def decide_next(self):        neigh = self.see_neighbors()        unvisited = [n for n in neigh if n not in self.visited_nodes]        if unvisited:            return min(unvisited, key=lambda n: self.heuristic(n))        else:            # backtrack if possible            if len(self.path) > 1:                return self.path[-2]            return self.position    def search(self):        while self.position != self.goal:            next_node = self.decide_next()            # якщо наступний вузол - поточний (застрягли), break            if next_node == self.position:                break            self.move_with_speed(next_node)        return self.path    def animate_path_with_speeds(self, delay=0.5):        pos = {node: (node[1], -node[0]) for node in self.graph.nodes()}        # draw base graph with edge speed labels (true assigned)        plt.figure(figsize=(6,6))        nx.draw(self.graph, pos, node_color="white", edgecolors="black", node_size=200)        # show assigned speed limits        edge_labels = {}        drawn = set()        for (u,v), digit in self.edge_speed_map.items():            if (v,u) in drawn: continue            edge_labels[(u,v)] = f"{digit*10}"            drawn.add((u,v)); drawn.add((v,u))        nx.draw_networkx_edge_labels(self.graph, pos, edge_labels=edge_labels, font_size=8)        # animate agent path step-by-step by plotting progressive edges        for i in range(1, len(self.path)+1):            plt.clf()            nx.draw(self.graph, pos, node_color="white", edgecolors="black", node_size=200)            nx.draw_networkx_nodes(self.graph, pos, nodelist=[self.start], node_color="green", node_size=300)            nx.draw_networkx_nodes(self.graph, pos, nodelist=[self.goal], node_color="red", node_size=300)            # draw assigned labels            nx.draw_networkx_edge_labels(self.graph, pos, edge_labels=edge_labels, font_size=8)            if i>1:                edges = [(self.path[j], self.path[j+1]) for j in range(i-1)]                nx.draw_networkx_edges(self.graph, pos, edgelist=edges, edge_color="orange", width=3)            nx.draw_networkx_nodes(self.graph, pos, nodelist=[self.path[i-1]], node_color="blue", node_size=250)            plt.title("Agent path and assigned speed limits (km/h)")            plt.pause(delay)        plt.show()# ------------------- Utility: build dataset mapping label->images -------------------def build_mnist_dict(x_all, y_all):    """Повертає dict: label -> list of images shaped (28,28,1) normalized"""    d = defaultdict(list)    for img, lbl in zip(x_all, y_all):        d[int(lbl)].append(img)    return d# ------------------- Main orchestration -------------------def main(train_model=False, epochs=3):    # 1) Граф    graph_creator = Create_Graph(5, remove_edges=13)    graph = graph_creator.graph    graph_creator.assign_random_speed_signs()    # 2) Prepare MNIST dataset    (x_train, y_train, y_train_cat), (x_test, y_test, y_test_cat) = prepare_mnist_2_9()    # 3) Build or load model    model_path = "speed_cnn.h5"    if (not train_model) and os.path.exists(model_path):        print("Loading pretrained model...")        model = tf.keras.models.load_model(model_path)    else:        print("Building and training model (digits 2..9)...")        model = build_cnn()        # train on small subset to speed up for demo        model.fit(x_train, y_train_cat, epochs=epochs, batch_size=128, validation_data=(x_test, y_test_cat))        model.save(model_path)        print(f"Model saved to {model_path}")    # 4) Build dict digit->images (use train+test)    x_all = np.concatenate([x_train, x_test], axis=0)    y_all = np.concatenate([y_train, y_test], axis=0)    mnist_images_by_label = build_mnist_dict(x_all, y_all)    # 5) Create agent and run search with speed recognition    start = (0,0)    goal = (4,4)    agent = Agent(graph, graph_creator.edge_speed, mnist_images_by_label, model, start, goal)    path = agent.search()    # 6) Output results    print("Final path:", path)    print("Traversed edges and speeds (format: ((u,v), speed_kmh, true_digit, pred_digit))")    for rec in agent.traversed_speeds:        print(rec)    # 7) Show graph with assigned speed labels and animate path    graph_creator.visualization()  # shows assigned speeds    agent.animate_path_with_speeds(delay=0.4)if __name__ == "__main__":    # Set to True if you want to train model now (may take time). Default False: loads 'speed_cnn.h5' if exists.    main(train_model=False, epochs=3)