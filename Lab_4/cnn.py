# cnn.py (Модуль комп'ютерного зору)import tensorflow as tfimport numpy as npimport randomimport os# Глобальні змінні для зберігання моделі та зображеньGLOBAL_MODEL = NoneSIMULATION_IMAGES = {}VALID_DIGITS = np.arange(2, 10)  # Цифри 2, 3, ..., 9def prepare_and_train_cnn():    """Створює та тренує модель CNN для розпізнавання цифр MNIST (2-9)."""    # Завантаження даних    (x_train, y_train), (x_test, y_test) = tf.keras.datasets.mnist.load_data()    # Створення масок для фільтрації: залишаємо тільки цифри 2-9    train_mask = np.isin(y_train, VALID_DIGITS)    test_mask = np.isin(y_test, VALID_DIGITS)    x_train, y_train = x_train[train_mask], y_train[train_mask]    x_test, y_test = x_test[test_mask], y_test[test_mask]    # Перетворення та нормалізація    x_train = np.expand_dims(x_train.astype('float32') / 255.0, -1)    x_test = np.expand_dims(x_test.astype('float32') / 255.0, -1)    # Зсув міток: 2 -> 0, 9 -> 7 (Всього 8 класів)    y_train_shifted = y_train - 2    y_test_shifted = y_test - 2    # One-Hot Encoding    y_train_cat = tf.keras.utils.to_categorical(y_train_shifted, num_classes=8)    y_test_cat = tf.keras.utils.to_categorical(y_test_shifted, num_classes=8)    # Архітектура моделі (використовуємо tf.keras.layers)    model = tf.keras.models.Sequential([        tf.keras.layers.Conv2D(32, (3, 3), activation='relu', input_shape=(28, 28, 1)),        tf.keras.layers.MaxPooling2D((2, 2)),        tf.keras.layers.Conv2D(64, (3, 3), activation='relu'),        tf.keras.layers.MaxPooling2D((2, 2)),        tf.keras.layers.Flatten(),        tf.keras.layers.Dense(100, activation='relu'),        tf.keras.layers.Dense(8, activation='softmax')    ])    # Компіляція та тренування    model.compile(optimizer='adam', loss='categorical_crossentropy',                  metrics=['accuracy'])    print("Модель CNN не знайдена. Запуск тренування...")    model.fit(x_train, y_train_cat, epochs=5, batch_size=32,              validation_data=(x_test, y_test_cat), verbose=0)    # Збереження моделі    model.save("speed_sign_cnn.h5")    print("Модель успішно збережена як speed_sign_cnn.h5")    return modeldef load_sign_images():    """Завантажує та зберігає зображення знаків (цифр 2-9) для симуляції камери."""    global SIMULATION_IMAGES    (x_train, y_train), _ = tf.keras.datasets.mnist.load_data()    x_train = np.expand_dims(x_train.astype('float32') / 255.0, -1)    for digit in VALID_DIGITS:        SIMULATION_IMAGES[digit] = x_train[y_train == digit]def get_sign_image(digit_value):    """Повертає випадкове зображення цифри для симуляції камери."""    if digit_value not in SIMULATION_IMAGES:        load_sign_images()    if digit_value not in SIMULATION_IMAGES:        raise ValueError(f"Цифра {digit_value} не підтримується як знак.")    images = SIMULATION_IMAGES[digit_value]    return random.choice(images)def get_cnn_model():    """Завантажує або тренує і повертає збережену модель CNN."""    global GLOBAL_MODEL    if GLOBAL_MODEL is None:        if not os.path.exists("speed_sign_cnn.h5"):            GLOBAL_MODEL = prepare_and_train_cnn()        else:            print("Завантаження збереженої моделі CNN з speed_sign_cnn.h5")            GLOBAL_MODEL = tf.keras.models.load_model("speed_sign_cnn.h5")    return GLOBAL_MODELdef recognize_sign(image_data):    """Приймає зображення знака, повертає визначену швидкість (20-90 км/год)."""    model = get_cnn_model()    # Форматування вхідних даних    input_data = np.expand_dims(image_data, 0)    # Прогноз    predictions = model.predict(input_data, verbose=0)    # Отримання класу    predicted_class = np.argmax(predictions[0])    # Зворотний зсув: predicted_digit = class_index + 2    predicted_digit = predicted_class + 2    # Перетворення цифри на швидкість    return predicted_digit * 10